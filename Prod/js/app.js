 /*== Dont Edit is File compile ! ==*/ (()=>{/* App By JeCodeLeSoir*//* Menu */const button = document.querySelector(".button");const menu = document.querySelector(".menu");button.addEventListener('click', () => { menu.classList.toggle("show");});window.addEventListener('load', ()=>{ const ElementMenu = document.querySelector("#menu"); const ElementFocus = document.querySelector("[go-focus]"); if(ElementFocus !== undefined){ setTimeout(()=>{ ElementFocus.focus(); window.scroll({ top: ElementMenu.offsetTop, left: 0, behavior: 'smooth' }); }, 100); };});/* Carrousel */class Carrousel { constructor(imgs, button_l, button_r) { this.imgs = imgs; if (this.imgs.length > 0) { this.index = 0; this.min = 0; this.max = this.imgs.length - 1; this.intervalcache = setInterval(()=> this.Update(), 6000); this.Render(); button_l.addEventListener('click',()=> this.ClickLeft()); button_r.addEventListener('click',()=> this.ClickRight()); } }; static bind() { const imgs = document.querySelectorAll(".carrousel .imgs .item"); const button_l = document.querySelector(".left"); const button_r = document.querySelector(".right"); new Carrousel(imgs, button_l, button_r); }; Render() { this.imgs.forEach((e) => e.classList.remove('show')); this.imgs[this.index].classList.add('show'); }; ClickLeft() { if (this.index > this.min) this.index--; else this.index = this.max; this.Render(); clearInterval(this.intervalcache); this.intervalcache = setInterval(()=> this.Update(), 6000); }; ClickRight() { if (this.index < this.max) this.index++; else this.index = this.min; this.Render(); clearInterval(this.intervalcache); this.intervalcache = setInterval(()=> this.Update(), 6000); }; Update() { if (this.index < this.max) this.index++; else this.index = this.min; this.Render(); };};Carrousel.bind();/* Contact */const contact = document.querySelector(".contact");if (contact) { const message = document.querySelector(".contact .message"); contact.addEventListener('submit', async (event) => { event.preventDefault(); const data = new FormData(event.target); await fetch('api/contact.php', { 'method': 'post', 'body': data, }).then(async (event) => { const text = await event.text(); message.innerText = text; }); event.target.reset(); });};/* Game */async function LoadImage(w, h, src) { return await new Promise((resolve, reject) => { const img = new Image(w, h); img.src = src; img.addEventListener('load', (event) => { resolve(img); }); img.addEventListener('error', () => { reject(); }); });};(async () => { const player_texture = await LoadImage(64, 64, 'images/games/player.png'); const missile_texture = await LoadImage(32, 32, 'images/games/missile.png'); const asteroide_texture = await LoadImage(32, 32, 'images/games/asteroide.png'); const player_scale = 2; const missile_scale = 2; const asteroide_scale = 2; const GameMenu = document.querySelector(".game-menu"); const MessageGame = document.querySelector(".game-menu .message"); const BtnStart = document.querySelector(".game-start"); const canvas = document.querySelector(".game-engine"); const BtnUp = document.querySelector(".mobile-game-controls .controls .up"); const BtnDown = document.querySelector(".mobile-game-controls .controls .down"); const BtnA = document.querySelector(".mobile-game-controls .controls .btn-a"); if (canvas) { const gameControls = {}; function CreateControl(button, callback) { let interval; button.addEventListener("mousedown", function(event) { interval = setInterval(() => callback(true), 10); }); button.addEventListener("mouseup", function(event) { clearInterval(interval); callback(false); }); } CreateControl(BtnUp, (click)=> gameControls.up = click); CreateControl(BtnDown,(click)=> gameControls.down = click); CreateControl(BtnA, (click)=> gameControls.btnA = click); canvas.height = canvas.width; BtnStart.addEventListener('click', () => { Game(true); GameMenu.classList.remove('show'); }); var UpdateLogiqueGameCache = undefined; function Game(_IsStart) { document.body.style.overflowY = "hidden"; const Player = { x: 0, y: 0, width: (player_scale * player_texture.width) / 2, height: (player_scale * player_texture.height) / 2, timeoutMissile: 0, dead: false }; const missiles = []; const asteroides = []; var AsteroideSpawnTime = 0; var IsStart = _IsStart; if (canvas.getContext) { const context2d = canvas.getContext('2d'); var x = 0; var y = 0; var keyCodeMap = {}; onkeydown = onkeyup = function (e) { keyCodeMap[e.keyCode] = e.type == 'keydown'; }; canvas.height = canvas.width; console.log(canvas.width); console.log(canvas.height); function intersect(a, b) { return ( a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.height + a.y > b.y ); }; const UpdateLogiqueGame = () => { /*=== Control ===*/ if (!Player.dead) { if (keyCodeMap[38] || gameControls.up) { if (Player.y > 0) { Player.y = Player.y - 1 * 4; } } else if (keyCodeMap[40] || gameControls.down) { console.log("down"); if (Player.y < canvas.height - ((player_scale * player_texture.width) /2)) { Player.y = Player.y + 1 * 4; } } if (Player.timeoutMissile <= 0) { if (keyCodeMap[32] || gameControls.btnA) { missiles.push({ x: 5, y: Player.y + (Player.height / 2) - ((missile_texture.width * missile_scale) / 2), width: missile_texture.width * missile_scale, height: missile_texture.height * missile_scale }); Player.timeoutMissile = 20; } } Player.timeoutMissile--; }; /* === Asteroide Spawn Random ===*/ if (AsteroideSpawnTime <= 0) { asteroides.push({ x: canvas.width, y: (Math.random() * (canvas.height)) - (32 / 2), width: asteroide_texture.width * asteroide_scale, height: asteroide_texture.height * asteroide_scale }); AsteroideSpawnTime = 30; if (Player.color == "red") { Player.color = "transparent"; }; }; AsteroideSpawnTime--; /* === Asteroide Move rigth to left ===*/ for (var index = 0; index < asteroides.length; index++) { var asteroide = asteroides[index]; if (asteroide !== undefined) { if (asteroide.x < -50) { delete asteroides[index]; }; asteroide.x = asteroide.x - 2; }; }; /* === Missile Move left to rigth ===*/ for (var index = 0; index < missiles.length; index++) { var missile = missiles[index]; if (missile !== undefined) { if (missile.x > 500) { delete missiles[index]; }; missile.x = missile.x + 3; }; }; /* === Asteroide intersect player */ for (var index = 0; index < asteroides.length; index++) { var asteroide = asteroides[index]; if (asteroide !== undefined) { if (intersect(asteroide, Player)) { Player.dead = true; Player.color = "red"; }; }; }; /* === Missile intersect asteroide */ for (var Aindex = 0; Aindex < missiles.length; Aindex++) { var missile = missiles[Aindex]; if (missile !== undefined) { for (var Bindex = 0; Bindex < asteroides.length; Bindex++) { var asteroide = asteroides[Bindex]; if (asteroide !== undefined) { if (intersect(asteroide, missile)) { delete missiles[Aindex]; delete asteroides[Bindex]; }; }; }; }; }; }; UpdateLogiqueGameCache = setInterval(UpdateLogiqueGame, 10); function Clear() { context2d.clearRect(0, 0, canvas.width, canvas.height); context2d.fillStyle = "rgb(31, 31, 31)"; context2d.fillRect(0, 0, canvas.width, canvas.height); }; function FrameUpdate() { Clear(); missiles.forEach((missile) => { context2d.drawImage( missile_texture, 0, 0, missile_texture.width, missile_texture.height, missile.x, missile.y, missile_scale * missile_texture.width, missile_scale * missile_texture.height, ); }); if (!Player.dead) { context2d.fillStyle = Player.color; context2d.fillRect(0, Player.y, Player.width, Player.height); context2d.drawImage(player_texture, 0, 0, player_texture.width, player_texture.height, 0, Player.y, player_scale * player_texture.width, player_scale * player_texture.height, ); } else { Clear(); IsStart = false; clearInterval(UpdateLogiqueGameCache); document.body.style.overflowY = "auto"; MessageGame.innerHTML = "Vous Ãªtre mort !"; GameMenu.classList.add('show'); return } asteroides.forEach((asteroide) => { context2d.drawImage(asteroide_texture, 0, 0, asteroide_texture.width, asteroide_texture.height, asteroide.x, asteroide.y, asteroide_scale * asteroide_texture.width, asteroide_scale * asteroide_texture.height, ); }); if (IsStart) requestAnimationFrame(FrameUpdate); }; requestAnimationFrame(FrameUpdate); }; }; };})();/* Parallax */function offsetTop(element, acc = 0) { if (element.offsetParent) { return offsetTop(element.offsetParent, acc + element.offsetTop); } return acc + element.offsetTop;};class Parallax { constructor(element) { this.element = element; this.ratio = parseFloat(element.dataset.parallax); window.addEventListener('load', ()=> this.onScroll()); document.addEventListener('scroll', ()=> this.onScroll()); window.addEventListener('resize', ()=> this.onScroll()); }; onScroll() { const screenY = window.scrollY + window.innerHeight / 2; const elementY = offsetTop(this.element) + this.element.offsetHeight / 2; const diffY = elementY - screenY; this.element.style.setProperty("transform", `translateY(${diffY * -1 * this.ratio}px)`); } static bind() { return Array.from(document.querySelectorAll('[data-parallax]')).map((element) => { return new Parallax(element); }); };};Parallax.bind();})()